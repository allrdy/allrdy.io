import{A as AstroError,I as InvalidComponentArgs,a as AstroGlobUsedOutside,b as AstroGlobNoMatch,M as MissingMediaQueryDirective,N as NoMatchingImport,O as OnlyResponseCanBeReturned,c as NoClientOnlyHint,d as NoMatchingRenderer,e as NoClientEntrypoint}from"./chunk.65e20d8f.js";function validateArgs(e){return 3===e.length&&!(!e[0]||"object"!=typeof e[0])}function baseCreateComponent(e,t,r){const n=t?.split("/").pop()?.replace(".astro","")??"",o=(...t)=>{if(!validateArgs(t))throw new AstroError({...InvalidComponentArgs,message:InvalidComponentArgs.message(n)});return e(...t)};return Object.defineProperty(o,"name",{value:n,writable:!1}),o.isAstroComponentFactory=!0,o.moduleId=t,o.propagation=r,o}function createComponentWithOptions(e){return baseCreateComponent(e.factory,e.moduleId,e.propagation)}function createComponent(e,t,r){return"function"==typeof e?baseCreateComponent(e,t,r):createComponentWithOptions(e)}const ASTRO_VERSION="3.5.1";function createAstroGlobFn(){return e=>{if("string"==typeof e)throw new AstroError({...AstroGlobUsedOutside,message:AstroGlobUsedOutside.message(JSON.stringify(e))});let t=[...Object.values(e)];if(0===t.length)throw new AstroError({...AstroGlobNoMatch,message:AstroGlobNoMatch.message(JSON.stringify(e))});return Promise.all(t.map((e=>e())))}}function createAstro(e){return{site:e?new URL(e):void 0,generator:"Astro v3.5.1",glob:createAstroGlobFn()}}const{replace:replace}="",ca=/[&<>'"]/g,esca={"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;",'"':"&quot;"},pe=e=>esca[e],escape=e=>replace.call(e,ca,pe);function isPromise(e){return!!e&&"object"==typeof e&&"function"==typeof e.then}async function*streamAsyncIterator(e){const t=e.getReader();try{for(;;){const{done:e,value:r}=await t.read();if(e)return;yield r}}finally{t.releaseLock()}}const escapeHTML=escape;class HTMLBytes extends Uint8Array{}Object.defineProperty(HTMLBytes.prototype,Symbol.toStringTag,{get:()=>"HTMLBytes"});class HTMLString extends String{get[Symbol.toStringTag](){return"HTMLString"}}const markHTMLString=e=>e instanceof HTMLString?e:"string"==typeof e?new HTMLString(e):e;function isHTMLString(e){return"[object HTMLString]"===Object.prototype.toString.call(e)}function markHTMLBytes(e){return new HTMLBytes(e)}function hasGetReader(e){return"function"==typeof e.getReader}async function*unescapeChunksAsync(e){if(hasGetReader(e))for await(const t of streamAsyncIterator(e))yield unescapeHTML(t);else for await(const t of e)yield unescapeHTML(t)}function*unescapeChunks(e){for(const t of e)yield unescapeHTML(t)}function unescapeHTML(e){if(e&&"object"==typeof e){if(e instanceof Uint8Array)return markHTMLBytes(e);if(e instanceof Response&&e.body){return unescapeChunksAsync(e.body)}if("function"==typeof e.then)return Promise.resolve(e).then((e=>unescapeHTML(e)));if(Symbol.iterator in e)return unescapeChunks(e);if(Symbol.asyncIterator in e||hasGetReader(e))return unescapeChunksAsync(e)}return markHTMLString(e)}const RenderInstructionSymbol=Symbol.for("astro:render");function createRenderInstruction(e){return Object.defineProperty(e,RenderInstructionSymbol,{value:!0})}function isRenderInstruction(e){return e&&"object"==typeof e&&e[RenderInstructionSymbol]}function r(e){var t,n,o="";if("string"==typeof e||"number"==typeof e)o+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=r(e[t]))&&(o&&(o+=" "),o+=n);else for(t in e)e[t]&&(o&&(o+=" "),o+=t);return o}function clsx(){for(var e,t,n=0,o="";n<arguments.length;)(e=arguments[n++])&&(t=r(e))&&(o&&(o+=" "),o+=t);return o}const PROP_TYPE={Value:0,JSON:1,RegExp:2,Date:3,Map:4,Set:5,BigInt:6,URL:7,Uint8Array:8,Uint16Array:9,Uint32Array:10};function serializeArray(e,t={},r=new WeakSet){if(r.has(e))throw new Error(`Cyclic reference detected while serializing props for <${t.displayName} client:${t.hydrate}>!\n\nCyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);r.add(e);const n=e.map((e=>convertToSerializedForm(e,t,r)));return r.delete(e),n}function serializeObject(e,t={},r=new WeakSet){if(r.has(e))throw new Error(`Cyclic reference detected while serializing props for <${t.displayName} client:${t.hydrate}>!\n\nCyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);r.add(e);const n=Object.fromEntries(Object.entries(e).map((([e,n])=>[e,convertToSerializedForm(n,t,r)])));return r.delete(e),n}function convertToSerializedForm(e,t={},r=new WeakSet){switch(Object.prototype.toString.call(e)){case"[object Date]":return[PROP_TYPE.Date,e.toISOString()];case"[object RegExp]":return[PROP_TYPE.RegExp,e.source];case"[object Map]":return[PROP_TYPE.Map,serializeArray(Array.from(e),t,r)];case"[object Set]":return[PROP_TYPE.Set,serializeArray(Array.from(e),t,r)];case"[object BigInt]":return[PROP_TYPE.BigInt,e.toString()];case"[object URL]":return[PROP_TYPE.URL,e.toString()];case"[object Array]":return[PROP_TYPE.JSON,serializeArray(e,t,r)];case"[object Uint8Array]":return[PROP_TYPE.Uint8Array,Array.from(e)];case"[object Uint16Array]":return[PROP_TYPE.Uint16Array,Array.from(e)];case"[object Uint32Array]":return[PROP_TYPE.Uint32Array,Array.from(e)];default:return null!==e&&"object"==typeof e?[PROP_TYPE.Value,serializeObject(e,t,r)]:void 0===e?[PROP_TYPE.Value]:[PROP_TYPE.Value,e]}}function serializeProps(e,t){return JSON.stringify(serializeObject(e,t))}const transitionDirectivesToCopyOnIsland=Object.freeze(["data-astro-transition-scope","data-astro-transition-persist"]);function extractDirectives(e,t){let r={isPage:!1,hydration:null,props:{},propsWithoutTransitionAttributes:{}};for(const[n,o]of Object.entries(e))if(n.startsWith("server:")&&"server:root"===n&&(r.isPage=!0),n.startsWith("client:"))switch(r.hydration||(r.hydration={directive:"",value:"",componentUrl:"",componentExport:{value:""}}),n){case"client:component-path":r.hydration.componentUrl=o;break;case"client:component-export":r.hydration.componentExport.value=o;break;case"client:component-hydration":case"client:display-name":break;default:if(r.hydration.directive=n.split(":")[1],r.hydration.value=o,!t.has(r.hydration.directive)){const e=Array.from(t.keys()).map((e=>`client:${e}`)).join(", ");throw new Error(`Error: invalid hydration directive "${n}". Supported hydration methods: ${e}`)}if("media"===r.hydration.directive&&"string"!=typeof r.hydration.value)throw new AstroError(MissingMediaQueryDirective)}else r.props[n]=o,transitionDirectivesToCopyOnIsland.includes(n)||(r.propsWithoutTransitionAttributes[n]=o);for(const t of Object.getOwnPropertySymbols(e))r.props[t]=e[t],r.propsWithoutTransitionAttributes[t]=e[t];return r}async function generateHydrateScript(e,t){const{renderer:r,result:n,astroId:o,props:s,attrs:i}=e,{hydrate:a,componentUrl:l,componentExport:c}=t;if(!c.value)throw new AstroError({...NoMatchingImport,message:NoMatchingImport.message(t.displayName)});const d={children:"",props:{uid:o}};if(i)for(const[e,t]of Object.entries(i))d.props[e]=escapeHTML(t);d.props["component-url"]=await n.resolve(decodeURI(l)),r.clientEntrypoint&&(d.props["component-export"]=c.value,d.props["renderer-url"]=await n.resolve(decodeURI(r.clientEntrypoint)),d.props.props=escapeHTML(serializeProps(s,t))),d.props.ssr="",d.props.client=a;let p=await n.resolve("astro:scripts/before-hydration.js");return p.length&&(d.props["before-hydration-url"]=p),d.props.opts=escapeHTML(JSON.stringify({name:t.displayName,value:t.hydrateArgs||""})),transitionDirectivesToCopyOnIsland.forEach((e=>{s[e]&&(d.props[e]=s[e])})),d}const dictionary="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY",binary=dictionary.length;function bitwise(e){let t=0;if(0===e.length)return t;for(let r=0;r<e.length;r++){t=(t<<5)-t+e.charCodeAt(r),t&=t}return t}function shorthash(e){let t,r="",n=bitwise(e);const o=n<0?"Z":"";for(n=Math.abs(n);n>=binary;)t=n%binary,n=Math.floor(n/binary),r=dictionary[t]+r;return n>0&&(r=dictionary[n]+r),o+r}function isAstroComponentFactory(e){return null!=e&&!0===e.isAstroComponentFactory}function isAPropagatingComponent(e,t){let r=t.propagation||"none";return t.moduleId&&e.componentMetadata.has(t.moduleId)&&"none"===r&&(r=e.componentMetadata.get(t.moduleId).propagation),"in-tree"===r||"self"===r}const headAndContentSym=Symbol.for("astro.headAndContent");function isHeadAndContent(e){return"object"==typeof e&&!!e[headAndContentSym]}function createHeadAndContent(e,t){return{[headAndContentSym]:!0,head:e,content:t}}var astro_island_prebuilt_default='(()=>{var b=Object.defineProperty;var f=(c,o,i)=>o in c?b(c,o,{enumerable:!0,configurable:!0,writable:!0,value:i}):c[o]=i;var l=(c,o,i)=>(f(c,typeof o!="symbol"?o+"":o,i),i);var p;{let c={0:t=>m(t),1:t=>i(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(i(t)),5:t=>new Set(i(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},o=t=>{let[e,r]=t;return e in c?c[e](r):void 0},i=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,r])=>[e,o(r)]));customElements.get("astro-island")||customElements.define("astro-island",(p=class extends HTMLElement{constructor(){super(...arguments);l(this,"Component");l(this,"hydrator");l(this,"hydrate",async()=>{var d;if(!this.hydrator||!this.isConnected)return;let e=(d=this.parentElement)==null?void 0:d.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let r=this.querySelectorAll("astro-slot"),a={},h=this.querySelectorAll("template[data-astro-template]");for(let n of h){let s=n.closest(this.tagName);s!=null&&s.isSameNode(this)&&(a[n.getAttribute("data-astro-template")||"default"]=n.innerHTML,n.remove())}for(let n of r){let s=n.closest(this.tagName);s!=null&&s.isSameNode(this)&&(a[n.getAttribute("name")||"default"]=n.innerHTML)}let u;try{u=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(n){let s=this.getAttribute("component-url")||"<unknown>",y=this.getAttribute("component-export");throw y&&(s+=` (export ${y})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),n),n}await this.hydrator(this)(this.Component,u,a,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});l(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),r.disconnect(),this.childrenConnectedCallback()},r=new MutationObserver(()=>{var a;((a=this.lastChild)==null?void 0:a.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});r.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}start(){let e=JSON.parse(this.getAttribute("opts")),r=this.getAttribute("client");if(Astro[r]===void 0){window.addEventListener(`astro:${r}`,()=>this.start(),{once:!0});return}Astro[r](async()=>{let a=this.getAttribute("renderer-url"),[h,{default:u}]=await Promise.all([import(this.getAttribute("component-url")),a?import(a):()=>()=>{}]),d=this.getAttribute("component-export")||"default";if(!d.includes("."))this.Component=h[d];else{this.Component=h;for(let n of d.split("."))this.Component=this.Component[n]}return this.hydrator=u,this.hydrate},e,this)}attributeChangedCallback(){this.hydrate()}},l(p,"observedAttributes",["props"]),p))}})();';const ISLAND_STYLES="<style>astro-island,astro-slot,astro-static-slot{display:contents}</style>";function determineIfNeedsHydrationScript(e){return!e._metadata.hasHydrationScript&&(e._metadata.hasHydrationScript=!0)}function determinesIfNeedsDirectiveScript(e,t){return!e._metadata.hasDirectives.has(t)&&(e._metadata.hasDirectives.add(t),!0)}function getDirectiveScriptText(e,t){const r=e.clientDirectives.get(t);if(!r)throw new Error(`Unknown directive: ${t}`);return r}function getPrescripts(e,t,r){switch(t){case"both":return`${ISLAND_STYLES}<script>${getDirectiveScriptText(e,r)};${astro_island_prebuilt_default}<\/script>`;case"directive":return`<script>${getDirectiveScriptText(e,r)}<\/script>`}return""}const voidElementNames=/^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i,htmlBooleanAttributes=/^(allowfullscreen|async|autofocus|autoplay|controls|default|defer|disabled|disablepictureinpicture|disableremoteplayback|formnovalidate|hidden|loop|nomodule|novalidate|open|playsinline|readonly|required|reversed|scoped|seamless|itemscope)$/i,htmlEnumAttributes=/^(contenteditable|draggable|spellcheck|value)$/i,svgEnumAttributes=/^(autoReverse|externalResourcesRequired|focusable|preserveAlpha)$/i,STATIC_DIRECTIVES=new Set(["set:html","set:text"]),toIdent=e=>e.trim().replace(/(?:(?!^)\b\w|\s+|[^\w]+)/g,((e,t)=>/[^\w]|\s/.test(e)?"":0===t?e:e.toUpperCase())),toAttributeString=(e,t=!0)=>t?String(e).replace(/&/g,"&#38;").replace(/"/g,"&#34;"):e,kebab=e=>e.toLowerCase()===e?e:e.replace(/[A-Z]/g,(e=>`-${e.toLowerCase()}`)),toStyleString=e=>Object.entries(e).filter((([e,t])=>"string"==typeof t&&t.trim()||"number"==typeof t)).map((([e,t])=>"-"!==e[0]&&"-"!==e[1]?`${kebab(e)}:${t}`:`${e}:${t}`)).join(";");function defineScriptVars(e){let t="";for(const[r,n]of Object.entries(e))t+=`const ${toIdent(r)} = ${JSON.stringify(n)?.replace(/<\/script>/g,"\\x3C/script>")};\n`;return markHTMLString(t)}function formatList(e){return 1===e.length?e[0]:`${e.slice(0,-1).join(", ")} or ${e[e.length-1]}`}function addAttribute(e,t,r=!0){if(null==e)return"";if(!1===e)return htmlEnumAttributes.test(t)||svgEnumAttributes.test(t)?markHTMLString(` ${t}="false"`):"";if(STATIC_DIRECTIVES.has(t))return console.warn(`[astro] The "${t}" directive cannot be applied dynamically at runtime. It will not be rendered as an attribute.\n\nMake sure to use the static attribute syntax (\`${t}={value}\`) instead of the dynamic spread syntax (\`{...{ "${t}": value }}\`).`),"";if("class:list"===t){const n=toAttributeString(clsx(e),r);return""===n?"":markHTMLString(` ${t.slice(0,-5)}="${n}"`)}if("style"===t&&!(e instanceof HTMLString)){if(Array.isArray(e)&&2===e.length)return markHTMLString(` ${t}="${toAttributeString(`${toStyleString(e[0])};${e[1]}`,r)}"`);if("object"==typeof e)return markHTMLString(` ${t}="${toAttributeString(toStyleString(e),r)}"`)}return"className"===t?markHTMLString(` class="${toAttributeString(e,r)}"`):!0===e&&(t.startsWith("data-")||htmlBooleanAttributes.test(t))?markHTMLString(` ${t}`):markHTMLString(` ${t}="${toAttributeString(e,r)}"`)}function internalSpreadAttributes(e,t=!0){let r="";for(const[n,o]of Object.entries(e))r+=addAttribute(o,n,t);return markHTMLString(r)}function renderElement$1(e,{props:t,children:r=""},n=!0){const{lang:o,"data-astro-id":s,"define:vars":i,...a}=t;return i&&("style"===e&&(delete a["is:global"],delete a["is:scoped"]),"script"===e&&(delete a.hoist,r=defineScriptVars(i)+"\n"+r)),null!=r&&""!=r||!voidElementNames.test(e)?`<${e}${internalSpreadAttributes(a,n)}>${r}</${e}>`:`<${e}${internalSpreadAttributes(a,n)} />`}function renderToBufferDestination(e){const t=[],r={write:e=>t.push(e)},n=e(r);return{async renderToFinalDestination(e){for(const r of t)e.write(r);r.write=t=>e.write(t),await n}}}const uniqueElements=(e,t,r)=>{const n=JSON.stringify(e.props),o=e.children;return t===r.findIndex((e=>JSON.stringify(e.props)===n&&e.children==o))};function renderAllHeadContent(e){e._metadata.hasRenderedHead=!0;const t=Array.from(e.styles).filter(uniqueElements).map((e=>"stylesheet"===e.props.rel?renderElement$1("link",e):renderElement$1("style",e)));e.styles.clear();const r=Array.from(e.scripts).filter(uniqueElements).map((e=>renderElement$1("script",e,!1))),n=Array.from(e.links).filter(uniqueElements).map((e=>renderElement$1("link",e,!1)));let o=t.join("\n")+n.join("\n")+r.join("\n");if(e._metadata.extraHead.length>0)for(const t of e._metadata.extraHead)o+=t;return markHTMLString(o)}function*renderHead(){yield createRenderInstruction({type:"head"})}function*maybeRenderHead(){yield createRenderInstruction({type:"maybe-head"})}const slotString=Symbol.for("astro:slot-string");class SlotString extends HTMLString{instructions;[slotString];constructor(e,t){super(e),this.instructions=t,this[slotString]=!0}}function isSlotString(e){return!!e[slotString]}function renderSlot(e,t,r){return!t&&r?renderSlot(e,r):{async render(r){await renderChild(r,"function"==typeof t?t(e):t)}}}async function renderSlotToString(e,t,r){let n="",o=null;const s={write(t){t instanceof Response||("object"==typeof t&&"type"in t&&"string"==typeof t.type?(null===o&&(o=[]),o.push(t)):n+=chunkToString(e,t))}},i=renderSlot(e,t,r);return await i.render(s),markHTMLString(new SlotString(n,o))}async function renderSlots(e,t={}){let r=null,n={};return t&&await Promise.all(Object.entries(t).map((([t,o])=>renderSlotToString(e,o).then((e=>{e.instructions&&(null===r&&(r=[]),r.push(...e.instructions)),n[t]=e}))))),{slotInstructions:r,children:n}}const Fragment=Symbol.for("astro:fragment"),Renderer=Symbol.for("astro:renderer");new TextEncoder;const decoder=new TextDecoder;function stringifyChunk(e,t){if(isRenderInstruction(t)){const r=t;switch(r.type){case"directive":{const{hydration:t}=r;let n=t&&determineIfNeedsHydrationScript(e),o=t&&determinesIfNeedsDirectiveScript(e,t.directive),s=n?"both":o?"directive":null;if(s){let r=getPrescripts(e,s,t.directive);return markHTMLString(r)}return""}case"head":return e._metadata.hasRenderedHead||e.partial?"":renderAllHeadContent(e);case"maybe-head":return e._metadata.hasRenderedHead||e._metadata.headInTree||e.partial?"":renderAllHeadContent(e);default:throw new Error(`Unknown chunk type: ${t.type}`)}}else{if(t instanceof Response)return"";if(isSlotString(t)){let r="";const n=t;if(n.instructions)for(const t of n.instructions)r+=stringifyChunk(e,t);return r+=t.toString(),r}}return t.toString()}function chunkToString(e,t){return ArrayBuffer.isView(t)?decoder.decode(t):stringifyChunk(e,t)}function isRenderInstance(e){return!!e&&"object"==typeof e&&"render"in e&&"function"==typeof e.render}async function renderChild(e,t){if((t=await t)instanceof SlotString)e.write(t);else if(isHTMLString(t))e.write(t);else if(Array.isArray(t)){const r=t.map((e=>renderToBufferDestination((t=>renderChild(t,e)))));for(const t of r)t&&await t.renderToFinalDestination(e)}else if("function"==typeof t)await renderChild(e,t());else if("string"==typeof t)e.write(markHTMLString(escapeHTML(t)));else if(t||0===t)if(isRenderInstance(t))await t.render(e);else if(isRenderTemplateResult(t))await t.render(e);else if(isAstroComponentInstance(t))await t.render(e);else if(ArrayBuffer.isView(t))e.write(t);else if("object"==typeof t&&(Symbol.asyncIterator in t||Symbol.iterator in t))for await(const r of t)await renderChild(e,r);else e.write(t);else;}const astroComponentInstanceSym=Symbol.for("astro.componentInstance");class AstroComponentInstance{[astroComponentInstanceSym]=!0;result;props;slotValues;factory;returnValue;constructor(e,t,r,n){this.result=e,this.props=t,this.factory=n,this.slotValues={};for(const t in r){let n=!1,o=r[t](e);this.slotValues[t]=()=>n?r[t](e):(n=!0,o)}}async init(e){return void 0!==this.returnValue||(this.returnValue=this.factory(e,this.props,this.slotValues)),this.returnValue}async render(e){void 0===this.returnValue&&await this.init(this.result);let t=this.returnValue;isPromise(t)&&(t=await t),isHeadAndContent(t)?await t.content.render(e):await renderChild(e,t)}}function validateComponentProps(e,t){if(null!=e)for(const r of Object.keys(e))r.startsWith("client:")&&console.warn(`You are attempting to render <${t} ${r} />, but ${t} is an Astro component. Astro components do not render in the client and should not have a hydration directive. Please use a framework component for client rendering.`)}function createAstroComponentInstance(e,t,r,n,o={}){validateComponentProps(n,t);const s=new AstroComponentInstance(e,n,o,r);return isAPropagatingComponent(e,r)&&e._metadata.propagators.add(s),s}function isAstroComponentInstance(e){return"object"==typeof e&&!!e[astroComponentInstanceSym]}const renderTemplateResultSym=Symbol.for("astro.renderTemplateResult");class RenderTemplateResult{[renderTemplateResultSym]=!0;htmlParts;expressions;error;constructor(e,t){this.htmlParts=e,this.error=void 0,this.expressions=t.map((e=>isPromise(e)?Promise.resolve(e).catch((e=>{if(!this.error)throw this.error=e,e})):e))}async render(e){const t=this.expressions.map((e=>renderToBufferDestination((t=>{if(e||0===e)return renderChild(t,e)}))));for(let r=0;r<this.htmlParts.length;r++){const n=this.htmlParts[r],o=t[r];e.write(markHTMLString(n)),o&&await o.renderToFinalDestination(e)}}}function isRenderTemplateResult(e){return"object"==typeof e&&!!e[renderTemplateResultSym]}function renderTemplate(e,...t){return new RenderTemplateResult(e,t)}async function renderToString(e,t,r,n,o=!1,s){const i=await callComponentAsTemplateResultOrResponse(e,t,r,n,s);if(i instanceof Response)return i;let a="",l=!1;const c={write(t){if(o&&!l&&(l=!0,!e.partial&&!/<!doctype html/i.test(String(t)))){const t=e.compressHTML?"<!DOCTYPE html>":"<!DOCTYPE html>\n";a+=t}t instanceof Response||(a+=chunkToString(e,t))}};return await i.render(c),a}async function callComponentAsTemplateResultOrResponse(e,t,r,n,o){const s=await t(e,r,n);if(s instanceof Response)return s;if(!isRenderTemplateResult(s))throw new AstroError({...OnlyResponseCanBeReturned,message:OnlyResponseCanBeReturned.message(o?.route,typeof s),location:{file:o?.component}});return isHeadAndContent(s)?s.content:s}function componentIsHTMLElement(e){return"undefined"!=typeof HTMLElement&&HTMLElement.isPrototypeOf(e)}async function renderHTMLElement(e,t,r,n){const o=getHTMLElementName(t);let s="";for(const e in r)s+=` ${e}="${toAttributeString(await r[e])}"`;return markHTMLString(`<${o}${s}>${await renderSlotToString(e,n?.default)}</${o}>`)}function getHTMLElementName(e){const t=customElements.getName(e);if(t)return t;return e.name.replace(/^HTML|Element$/g,"").replace(/[A-Z]/g,"-$&").toLowerCase().replace(/^-/,"html-")}const needsHeadRenderingSymbol=Symbol.for("astro.needsHeadRendering"),rendererAliases=new Map([["solid","solid-js"]]);function guessRenderers(e){const t=e?.split(".").pop();switch(t){case"svelte":return["@astrojs/svelte"];case"vue":return["@astrojs/vue"];case"jsx":case"tsx":return["@astrojs/react","@astrojs/preact","@astrojs/solid-js","@astrojs/vue (jsx)"];default:return["@astrojs/react","@astrojs/preact","@astrojs/solid-js","@astrojs/vue","@astrojs/svelte","@astrojs/lit"]}}function isFragmentComponent(e){return e===Fragment}function isHTMLComponent(e){return e&&!0===e["astro:html"]}const ASTRO_SLOT_EXP=/\<\/?astro-slot\b[^>]*>/g,ASTRO_STATIC_SLOT_EXP=/\<\/?astro-static-slot\b[^>]*>/g;function removeStaticAstroSlot(e,t){const r=t?ASTRO_STATIC_SLOT_EXP:ASTRO_SLOT_EXP;return e.replace(r,"")}async function renderFrameworkComponent(e,t,r,n,o={}){if(!r&&!n["client:only"])throw new Error(`Unable to render ${t} because it is ${r}!\nDid you forget to import the component or is it possible there is a typo?`);const{renderers:s,clientDirectives:i}=e,a={astroStaticSlot:!0,displayName:t},{hydration:l,isPage:c,props:d,propsWithoutTransitionAttributes:p}=extractDirectives(n,i);let u,f="";l&&(a.hydrate=l.directive,a.hydrateArgs=l.value,a.componentExport=l.componentExport,a.componentUrl=l.componentUrl);const m=guessRenderers(a.componentUrl),y=s.filter((e=>"astro:jsx"!==e.name)),{children:h,slotInstructions:g}=await renderSlots(e,o);let S;if("only"!==a.hydrate){let t=!1;try{t=r&&r[Renderer]}catch{}if(t){const e=r[Renderer];S=s.find((({name:t})=>t===e))}if(!S){let t;for(const n of s)try{if(await n.ssr.check.call({result:e},r,d,h)){S=n;break}}catch(e){t??=e}if(!S&&t)throw t}if(!S&&"function"==typeof HTMLElement&&componentIsHTMLElement(r)){const t=await renderHTMLElement(e,r,n,o);return{render(e){e.write(t)}}}}else{if(a.hydrateArgs){const e=a.hydrateArgs,t=rendererAliases.has(e)?rendererAliases.get(e):e;S=s.find((({name:e})=>e===`@astrojs/${t}`||e===t))}if(S||1!==y.length||(S=y[0]),!S){const e=a.componentUrl?.split(".").pop();S=s.filter((({name:t})=>t===`@astrojs/${e}`||t===e))[0]}}if(S)"only"===a.hydrate?f=await renderSlotToString(e,o?.fallback):({html:f,attrs:u}=await S.ssr.renderToStaticMarkup.call({result:e},r,p,h,a));else{if("only"===a.hydrate)throw new AstroError({...NoClientOnlyHint,message:NoClientOnlyHint.message(a.displayName),hint:NoClientOnlyHint.hint(m.map((e=>e.replace("@astrojs/",""))).join("|"))});if("string"!=typeof r){const t=y.filter((e=>m.includes(e.name))),n=y.length>1;if(0===t.length)throw new AstroError({...NoMatchingRenderer,message:NoMatchingRenderer.message(a.displayName,a?.componentUrl?.split(".").pop(),n,y.length),hint:NoMatchingRenderer.hint(formatList(m.map((e=>"`"+e+"`"))))});if(1!==t.length)throw new Error(`Unable to render ${a.displayName}!\n\nThis component likely uses ${formatList(m)},\nbut Astro encountered an error during server-side rendering.\n\nPlease ensure that ${a.displayName}:\n1. Does not unconditionally access browser-specific globals like \`window\` or \`document\`.\n   If this is unavoidable, use the \`client:only\` hydration directive.\n2. Does not conditionally return \`null\` or \`undefined\` when rendered on the server.\n\nIf you're still stuck, please open an issue on GitHub or join us at https://astro.build/chat.`);S=t[0],({html:f,attrs:u}=await S.ssr.renderToStaticMarkup.call({result:e},r,p,h,a))}}if(S&&!S.clientEntrypoint&&"@astrojs/lit"!==S.name&&a.hydrate)throw new AstroError({...NoClientEntrypoint,message:NoClientEntrypoint.message(t,a.hydrate,S.name)});if(!f&&"string"==typeof r){const t=sanitizeElementName(r),n=Object.values(h).join(""),o=renderTemplate`<${t}${internalSpreadAttributes(d)}${markHTMLString(""===n&&voidElementNames.test(t)?"/>":`>${n}</${t}>`)}`;f="";const s={write(t){t instanceof Response||(f+=chunkToString(e,t))}};await o.render(s)}if(!l)return{render(e){if(g)for(const t of g)e.write(t);c||"astro:jsx"===S?.name?e.write(f):f&&f.length>0&&e.write(markHTMLString(removeStaticAstroSlot(f,S?.ssr?.supportsAstroStaticSlot??!1)))}};const b=shorthash(`\x3c!--${a.componentExport.value}:${a.componentUrl}--\x3e\n${f}\n${serializeProps(d,a)}`),A=await generateHydrateScript({renderer:S,result:e,astroId:b,props:d,attrs:u},a);let w=[];if(f){if(Object.keys(h).length>0)for(const e of Object.keys(h)){let t=S?.ssr?.supportsAstroStaticSlot?a.hydrate?"astro-slot":"astro-static-slot":"astro-slot",r="default"===e?`<${t}>`:`<${t} name="${e}">`;f.includes(r)||w.push(e)}}else w=Object.keys(h);const T=w.length>0?w.map((e=>`<template data-astro-template${"default"!==e?`="${e}"`:""}>${h[e]}</template>`)).join(""):"";return A.children=`${f??""}${T}`,A.children&&(A.props["await-children"]="",A.children+="\x3c!--astro:end--\x3e"),{render(e){if(g)for(const t of g)e.write(t);e.write(createRenderInstruction({type:"directive",hydration:l})),e.write(markHTMLString(renderElement$1("astro-island",A,!1)))}}}function sanitizeElementName(e){const t=/[&<>'"\s]+/g;return t.test(e)?e.trim().split(t)[0].trim():e}async function renderFragmentComponent(e,t={}){const r=await renderSlotToString(e,t?.default);return{render(e){null!=r&&e.write(r)}}}async function renderHTMLComponent(e,t,r,n={}){const{slotInstructions:o,children:s}=await renderSlots(e,n),i=t({slots:s}),a=o?o.map((t=>chunkToString(e,t))).join(""):"";return{render(e){e.write(markHTMLString(a+i))}}}function renderAstroComponent(e,t,r,n,o={}){const s=createAstroComponentInstance(e,t,r,n,o);return{async render(e){await s.render(e)}}}async function renderComponent(e,t,r,n,o={}){return isPromise(r)&&(r=await r),isFragmentComponent(r)?await renderFragmentComponent(e,o):(n=normalizeProps(n),isHTMLComponent(r)?await renderHTMLComponent(e,r,n,o):isAstroComponentFactory(r)?renderAstroComponent(e,t,r,n,o):await renderFrameworkComponent(e,t,r,n,o))}function normalizeProps(e){if(void 0!==e["class:list"]){const t=e["class:list"];delete e["class:list"],e.class=clsx(e.class,t),""===e.class&&delete e.class}return e}async function renderComponentToString(e,t,r,n,o={},s=!1,i){let a="",l=!1,c="";if(nonAstroPageNeedsHeadInjection(r))for(const t of maybeRenderHead())c+=chunkToString(e,t);try{const i={write(t){if(s&&!l&&(l=!0,!e.partial&&!/<!doctype html/i.test(String(t)))){const t=e.compressHTML?"<!DOCTYPE html>":"<!DOCTYPE html>\n";a+=t+c}t instanceof Response||(a+=chunkToString(e,t))}},d=await renderComponent(e,t,r,n,o);await d.render(i)}catch(e){throw AstroError.is(e)&&!e.loc&&e.setLocation({file:i?.component}),e}return a}function nonAstroPageNeedsHeadInjection(e){return!!e?.[needsHeadRenderingSymbol]}const ClientOnlyPlaceholder="astro-client-only";class Skip{constructor(e){this.vnode=e,this.count=0}count;increment(){this.count++}haveNoTried(){return 0===this.count}isCompleted(){return this.count>2}static symbol=Symbol("astro:jsx:skip")}let originalConsoleError,consoleFilterRefs=0;async function renderJSX(e,t){switch(!0){case t instanceof HTMLString:return""===t.toString().trim()?"":t;case"string"==typeof t:return markHTMLString(escapeHTML(t));case"function"==typeof t:return t;case!t&&0!==t:return"";case Array.isArray(t):return markHTMLString((await Promise.all(t.map((t=>renderJSX(e,t))))).join(""))}let r;return r=t.props&&t.props[Skip.symbol]?t.props[Skip.symbol]:new Skip(t),renderJSXVNode(e,t,r)}async function renderJSXVNode(e,t,r){if(isVNode(t)){switch(!0){case!t.type:throw new Error(`Unable to render ${e.pathname} because it contains an undefined Component!\nDid you forget to import the component or is it possible there is a typo?`);case t.type===Symbol.for("astro:fragment"):return renderJSX(e,t.props.children);case t.type.isAstroComponentFactory:{let r={},n={};for(const[o,s]of Object.entries(t.props??{}))"children"===o||s&&"object"==typeof s&&s.$$slot?n["children"===o?"default":o]=()=>renderJSX(e,s):r[o]=s;const o=await renderToString(e,t.type,r,n);if(o instanceof Response)throw o;return markHTMLString(o)}case!t.type&&0!==t.type:return"";case"string"==typeof t.type&&t.type!==ClientOnlyPlaceholder:return markHTMLString(await renderElement(e,t.type,t.props??{}))}if(t.type){let n=function(e){return Array.isArray(e)?e.map((e=>n(e))):isVNode(e)&&"slot"in e.props?(i[e.props.slot]=[...i[e.props.slot]??[],e],void delete e.props.slot):void i.default.push(e)};if("function"==typeof t.type&&t.type["astro:renderer"]&&r.increment(),"function"==typeof t.type&&t.props["server:root"]){const r=await t.type(t.props??{});return await renderJSX(e,r)}if("function"==typeof t.type)if(r.haveNoTried()||r.isCompleted()){useConsoleFilter();try{const n=await t.type(t.props??{});let o;if(n?.[AstroJSX])return o=await renderJSXVNode(e,n,r),o;if(!n)return o=await renderJSXVNode(e,n,r),o}catch(e){if(r.isCompleted())throw e;r.increment()}finally{finishUsingConsoleFilter()}}else r.increment();const{children:o=null,...s}=t.props??{},i={default:[]};n(o);for(const[e,t]of Object.entries(s))t.$$slot&&(i[e]=t,delete s[e]);const a=[],l={};for(const[t,r]of Object.entries(i))a.push(renderJSX(e,r).then((e=>{0!==e.toString().trim().length&&(l[t]=()=>e)})));let c;return await Promise.all(a),s[Skip.symbol]=r,c=t.type===ClientOnlyPlaceholder&&t.props["client:only"]?await renderComponentToString(e,t.props["client:display-name"]??"",null,s,l):await renderComponentToString(e,"function"==typeof t.type?t.type.name:t.type,t.type,s,l),markHTMLString(c)}}return markHTMLString(`${t}`)}async function renderElement(e,t,{children:r,...n}){return markHTMLString(`<${t}${spreadAttributes(n)}${markHTMLString(null!=r&&""!=r||!voidElementNames.test(t)?`>${null==r?"":await renderJSX(e,prerenderElementChildren(t,r))}</${t}>`:"/>")}`)}function prerenderElementChildren(e,t){return"string"!=typeof t||"style"!==e&&"script"!==e?t:markHTMLString(t)}function useConsoleFilter(){if(consoleFilterRefs++,!originalConsoleError){originalConsoleError=console.error;try{console.error=filteredConsoleError}catch(e){}}}function finishUsingConsoleFilter(){consoleFilterRefs--}function filteredConsoleError(e,...t){if(consoleFilterRefs>0&&"string"==typeof e){if(e.includes("Warning: Invalid hook call.")&&e.includes("https://reactjs.org/link/invalid-hook-call"))return}originalConsoleError(e,...t)}function renderScriptElement({props:e,children:t}){return renderElement$1("script",{props:e,children:t})}function renderUniqueStylesheet(e,t){return"external"===t.type?Array.from(e.styles).some((e=>e.props.href===t.src))?"":renderElement$1("link",{props:{rel:"stylesheet",href:t.src},children:""}):"inline"===t.type?Array.from(e.styles).some((e=>e.children.includes(t.content)))?"":renderElement$1("style",{props:{},children:t.content}):void 0}function __astro_tag_component__(e,t){e&&"function"==typeof e&&Object.defineProperty(e,Renderer,{value:t,enumerable:!1,writable:!1})}function spreadAttributes(e={},t,{class:r}={}){let n="";r&&(void 0!==e.class?e.class+=` ${r}`:void 0!==e["class:list"]?e["class:list"]=[e["class:list"],r]:e.class=r);for(const[t,r]of Object.entries(e))n+=addAttribute(r,t,!0);return markHTMLString(n)}function defineStyleVars(e){let t="",r=Array.isArray(e)?e:[e];for(const e of r)for(const[r,n]of Object.entries(e))(n||0===n)&&(t+=`--${r}: ${n};`);return markHTMLString(t)}const AstroJSX="astro:jsx",Empty=Symbol("empty"),toSlotName=e=>e;function isVNode(e){return e&&"object"==typeof e&&e[AstroJSX]}function transformSlots(e){if("string"==typeof e.type)return e;const t={};if(isVNode(e.props.children)){const r=e.props.children;if(!isVNode(r))return;if(!("slot"in r.props))return;const n=toSlotName(r.props.slot);t[n]=[r],t[n].$$slot=!0,delete r.props.slot,delete e.props.children}Array.isArray(e.props.children)&&(e.props.children=e.props.children.map((e=>{if(!isVNode(e))return e;if(!("slot"in e.props))return e;const r=toSlotName(e.props.slot);return Array.isArray(t[r])?t[r].push(e):(t[r]=[e],t[r].$$slot=!0),delete e.props.slot,Empty})).filter((e=>e!==Empty))),Object.assign(e.props,t)}function markRawChildren(e){return"string"==typeof e?markHTMLString(e):Array.isArray(e)?e.map((e=>markRawChildren(e))):e}function transformSetDirectives(e){if("set:html"in e.props||"set:text"in e.props){if("set:html"in e.props){const t=markRawChildren(e.props["set:html"]);return delete e.props["set:html"],void Object.assign(e.props,{children:t})}if("set:text"in e.props){const t=e.props["set:text"];return delete e.props["set:text"],void Object.assign(e.props,{children:t})}}}function createVNode(e,t){const r={[Renderer]:"astro:jsx",[AstroJSX]:!0,type:e,props:t??{}};return transformSetDirectives(r),transformSlots(r),r}export{AstroJSX as A,Fragment as F,__astro_tag_component__ as _,renderScriptElement as a,createHeadAndContent as b,createComponent as c,renderTemplate as d,renderComponent as e,createAstro as f,defineStyleVars as g,addAttribute as h,renderSlot as i,renderHead as j,renderJSX as k,createVNode as l,maybeRenderHead as m,renderUniqueStylesheet as r,spreadAttributes as s,unescapeHTML as u};